(self["webpackChunk_lenna_project_watermark"] = self["webpackChunk_lenna_project_watermark"] || []).push([[333],{

/***/ 333:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhotonImage": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.nt),
/* harmony export */   "Rgb": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ss),
/* harmony export */   "SamplingFilter": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.VY),
/* harmony export */   "__wbg_appendChild_6ae001e6d3556190": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.DM),
/* harmony export */   "__wbg_body_0d97f334de622953": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.$n),
/* harmony export */   "__wbg_call_cb478d88f3068c91": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.YD),
/* harmony export */   "__wbg_createElement_ba61aad8af6be7f4": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Vi),
/* harmony export */   "__wbg_data_7db9e348ce1855fa": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.jv),
/* harmony export */   "__wbg_document_249e9cf340780f93": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__._4),
/* harmony export */   "__wbg_drawImage_8012170741749614": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.HS),
/* harmony export */   "__wbg_error_4bb6c2a97407129a": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.kF),
/* harmony export */   "__wbg_getContext_d778ffc8203f64ae": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.o1),
/* harmony export */   "__wbg_getImageData_6e56dc172cd2ed36": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.JF),
/* harmony export */   "__wbg_globalThis_f0ca0bbb0149cf3d": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.IV),
/* harmony export */   "__wbg_global_c3c8325ae8c7f1a9": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.VB),
/* harmony export */   "__wbg_height_872c06b1bc666dd9": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.cl),
/* harmony export */   "__wbg_height_d9aa5f566b4ad3b1": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ei),
/* harmony export */   "__wbg_instanceof_CanvasRenderingContext2d_eea9cd931eb496b7": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.xO),
/* harmony export */   "__wbg_instanceof_HtmlCanvasElement_e0e251da2aa0b541": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ke),
/* harmony export */   "__wbg_instanceof_Window_9c4fd26090e1d029": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.S1),
/* harmony export */   "__wbg_new_59cb74e423758ede": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.h9),
/* harmony export */   "__wbg_newnoargs_3efc7bfa69a681f9": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Yu),
/* harmony export */   "__wbg_newwithu8clampedarrayandsh_daf4b2743e8c858d": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.pj),
/* harmony export */   "__wbg_putImageData_a0ab6f94c11984ac": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.OI),
/* harmony export */   "__wbg_self_05c54dcacb623b9a": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.M8),
/* harmony export */   "__wbg_setheight_5b882973e84fa13c": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.xo),
/* harmony export */   "__wbg_settextContent_fa342bf9999ed3eb": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.MP),
/* harmony export */   "__wbg_setwidth_fd251e9da5abcced": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Yw),
/* harmony export */   "__wbg_stack_558ba5917b466edd": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Dz),
/* harmony export */   "__wbg_width_0c52428553322c27": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.tQ),
/* harmony export */   "__wbg_width_5843e31ec081f978": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.li),
/* harmony export */   "__wbg_window_9777ce446d12989f": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.JC),
/* harmony export */   "__wbindgen_debug_string": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.fY),
/* harmony export */   "__wbindgen_is_undefined": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.XP),
/* harmony export */   "__wbindgen_json_parse": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.t$),
/* harmony export */   "__wbindgen_json_serialize": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.r1),
/* harmony export */   "__wbindgen_object_clone_ref": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.m_),
/* harmony export */   "__wbindgen_object_drop_ref": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ug),
/* harmony export */   "__wbindgen_rethrow": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.nD),
/* harmony export */   "__wbindgen_throw": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Or),
/* harmony export */   "adjust_contrast": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.NC),
/* harmony export */   "alter_blue_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.nG),
/* harmony export */   "alter_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.M4),
/* harmony export */   "alter_channels": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.XA),
/* harmony export */   "alter_green_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.uR),
/* harmony export */   "alter_red_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.rm),
/* harmony export */   "alter_two_channels": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.fD),
/* harmony export */   "apply_gradient": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ws),
/* harmony export */   "b_grayscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.PS),
/* harmony export */   "base64_to_image": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Zk),
/* harmony export */   "base64_to_vec": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.gL),
/* harmony export */   "blend": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.NH),
/* harmony export */   "box_blur": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.vJ),
/* harmony export */   "cali": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.fs),
/* harmony export */   "colorize": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.SJ),
/* harmony export */   "create_gradient": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Q8),
/* harmony export */   "crop": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.d1),
/* harmony export */   "crop_img_browser": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Iw),
/* harmony export */   "darken_hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.nZ),
/* harmony export */   "darken_hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.dN),
/* harmony export */   "darken_lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ir),
/* harmony export */   "decompose_max": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ZL),
/* harmony export */   "decompose_min": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Zo),
/* harmony export */   "defaultConfig": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.u_),
/* harmony export */   "desaturate": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.vG),
/* harmony export */   "desaturate_hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.TV),
/* harmony export */   "desaturate_hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.VL),
/* harmony export */   "desaturate_lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ei),
/* harmony export */   "description": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.WL),
/* harmony export */   "detect_135_deg_lines": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.kt),
/* harmony export */   "detect_45_deg_lines": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.wO),
/* harmony export */   "detect_horizontal_lines": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.eY),
/* harmony export */   "detect_vertical_lines": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.s6),
/* harmony export */   "dramatic": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.kw),
/* harmony export */   "edge_detection": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.sW),
/* harmony export */   "edge_one": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.lf),
/* harmony export */   "emboss": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.D$),
/* harmony export */   "filter": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.hX),
/* harmony export */   "firenze": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.og),
/* harmony export */   "fliph": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.xn),
/* harmony export */   "flipv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.My),
/* harmony export */   "g_grayscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.dI),
/* harmony export */   "gaussian_blur": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.zx),
/* harmony export */   "get_image_data": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.fh),
/* harmony export */   "golden": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.o3),
/* harmony export */   "grayscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.se),
/* harmony export */   "grayscale_human_corrected": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ZH),
/* harmony export */   "grayscale_shades": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Nw),
/* harmony export */   "horizontal_strips": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.YX),
/* harmony export */   "hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ym),
/* harmony export */   "hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.mC),
/* harmony export */   "hue_rotate_hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.KE),
/* harmony export */   "hue_rotate_hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Bc),
/* harmony export */   "hue_rotate_lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.xc),
/* harmony export */   "id": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   "identity": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.yR),
/* harmony export */   "inc_brightness": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.DT),
/* harmony export */   "invert": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.U_),
/* harmony export */   "laplace": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.j9),
/* harmony export */   "lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.tW),
/* harmony export */   "lighten_hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.pm),
/* harmony export */   "lighten_hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.eP),
/* harmony export */   "lighten_lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ZR),
/* harmony export */   "lix": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.xP),
/* harmony export */   "lofi": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.aE),
/* harmony export */   "mix_with_colour": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.c),
/* harmony export */   "monochrome": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.OT),
/* harmony export */   "multiple_offsets": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ou),
/* harmony export */   "name": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.u2),
/* harmony export */   "neue": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.hh),
/* harmony export */   "noise_reduction": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.g$),
/* harmony export */   "obsidian": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Mb),
/* harmony export */   "offset": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.cv),
/* harmony export */   "offset_blue": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.FJ),
/* harmony export */   "offset_green": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Yc),
/* harmony export */   "offset_red": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.MV),
/* harmony export */   "oil": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.vK),
/* harmony export */   "open_image": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.mZ),
/* harmony export */   "pastel_pink": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.jN),
/* harmony export */   "prewitt_horizontal": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.XJ),
/* harmony export */   "primary": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.T$),
/* harmony export */   "process": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.N4),
/* harmony export */   "putImageData": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.P_),
/* harmony export */   "r_grayscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Hp),
/* harmony export */   "remove_blue_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.ow),
/* harmony export */   "remove_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.O5),
/* harmony export */   "remove_green_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.X7),
/* harmony export */   "remove_red_channel": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.EF),
/* harmony export */   "resize": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.SI),
/* harmony export */   "resize_img_browser": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.JZ),
/* harmony export */   "run": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.KH),
/* harmony export */   "ryo": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.hg),
/* harmony export */   "saturate_hsl": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.zP),
/* harmony export */   "saturate_hsv": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.w2),
/* harmony export */   "saturate_lch": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Uj),
/* harmony export */   "seam_carve": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.oJ),
/* harmony export */   "selective_desaturate": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.M),
/* harmony export */   "selective_greyscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.p),
/* harmony export */   "selective_hue_rotate": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.S5),
/* harmony export */   "selective_lighten": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.m2),
/* harmony export */   "selective_saturate": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.lN),
/* harmony export */   "sepia": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.HI),
/* harmony export */   "sharpen": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.dF),
/* harmony export */   "single_channel_grayscale": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.YQ),
/* harmony export */   "sobel_horizontal": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.WB),
/* harmony export */   "sobel_vertical": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.c1),
/* harmony export */   "solarize": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.x),
/* harmony export */   "solarize_retimg": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Qf),
/* harmony export */   "swap_channels": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.qc),
/* harmony export */   "threshold": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Lj),
/* harmony export */   "tint": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.nV),
/* harmony export */   "to_image_data": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Sz),
/* harmony export */   "to_raw_pixels": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.Kf),
/* harmony export */   "vertical_strips": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.BG),
/* harmony export */   "watermark": () => (/* reexport safe */ _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__.f9)
/* harmony export */ });
/* harmony import */ var _watermark_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(718);



/***/ }),

/***/ 718:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u_": () => (/* binding */ defaultConfig),
/* harmony export */   "id": () => (/* binding */ id),
/* harmony export */   "u2": () => (/* binding */ name),
/* harmony export */   "WL": () => (/* binding */ description),
/* harmony export */   "N4": () => (/* binding */ process),
/* harmony export */   "M4": () => (/* binding */ alter_channel),
/* harmony export */   "rm": () => (/* binding */ alter_red_channel),
/* harmony export */   "uR": () => (/* binding */ alter_green_channel),
/* harmony export */   "nG": () => (/* binding */ alter_blue_channel),
/* harmony export */   "fD": () => (/* binding */ alter_two_channels),
/* harmony export */   "XA": () => (/* binding */ alter_channels),
/* harmony export */   "O5": () => (/* binding */ remove_channel),
/* harmony export */   "EF": () => (/* binding */ remove_red_channel),
/* harmony export */   "X7": () => (/* binding */ remove_green_channel),
/* harmony export */   "ow": () => (/* binding */ remove_blue_channel),
/* harmony export */   "qc": () => (/* binding */ swap_channels),
/* harmony export */   "U_": () => (/* binding */ invert),
/* harmony export */   "S5": () => (/* binding */ selective_hue_rotate),
/* harmony export */   "m2": () => (/* binding */ selective_lighten),
/* harmony export */   "M": () => (/* binding */ selective_desaturate),
/* harmony export */   "lN": () => (/* binding */ selective_saturate),
/* harmony export */   "p": () => (/* binding */ selective_greyscale),
/* harmony export */   "d1": () => (/* binding */ crop),
/* harmony export */   "Iw": () => (/* binding */ crop_img_browser),
/* harmony export */   "xn": () => (/* binding */ fliph),
/* harmony export */   "My": () => (/* binding */ flipv),
/* harmony export */   "JZ": () => (/* binding */ resize_img_browser),
/* harmony export */   "SI": () => (/* binding */ resize),
/* harmony export */   "oJ": () => (/* binding */ seam_carve),
/* harmony export */   "OT": () => (/* binding */ monochrome),
/* harmony export */   "HI": () => (/* binding */ sepia),
/* harmony export */   "se": () => (/* binding */ grayscale),
/* harmony export */   "ZH": () => (/* binding */ grayscale_human_corrected),
/* harmony export */   "vG": () => (/* binding */ desaturate),
/* harmony export */   "Zo": () => (/* binding */ decompose_min),
/* harmony export */   "ZL": () => (/* binding */ decompose_max),
/* harmony export */   "Nw": () => (/* binding */ grayscale_shades),
/* harmony export */   "Hp": () => (/* binding */ r_grayscale),
/* harmony export */   "dI": () => (/* binding */ g_grayscale),
/* harmony export */   "PS": () => (/* binding */ b_grayscale),
/* harmony export */   "YQ": () => (/* binding */ single_channel_grayscale),
/* harmony export */   "Lj": () => (/* binding */ threshold),
/* harmony export */   "f9": () => (/* binding */ watermark),
/* harmony export */   "NH": () => (/* binding */ blend),
/* harmony export */   "Q8": () => (/* binding */ create_gradient),
/* harmony export */   "ws": () => (/* binding */ apply_gradient),
/* harmony export */   "KH": () => (/* binding */ run),
/* harmony export */   "fh": () => (/* binding */ get_image_data),
/* harmony export */   "P_": () => (/* binding */ putImageData),
/* harmony export */   "mZ": () => (/* binding */ open_image),
/* harmony export */   "Kf": () => (/* binding */ to_raw_pixels),
/* harmony export */   "Zk": () => (/* binding */ base64_to_image),
/* harmony export */   "gL": () => (/* binding */ base64_to_vec),
/* harmony export */   "Sz": () => (/* binding */ to_image_data),
/* harmony export */   "tW": () => (/* binding */ lch),
/* harmony export */   "Ym": () => (/* binding */ hsl),
/* harmony export */   "mC": () => (/* binding */ hsv),
/* harmony export */   "KE": () => (/* binding */ hue_rotate_hsl),
/* harmony export */   "Bc": () => (/* binding */ hue_rotate_hsv),
/* harmony export */   "xc": () => (/* binding */ hue_rotate_lch),
/* harmony export */   "zP": () => (/* binding */ saturate_hsl),
/* harmony export */   "Uj": () => (/* binding */ saturate_lch),
/* harmony export */   "w2": () => (/* binding */ saturate_hsv),
/* harmony export */   "ZR": () => (/* binding */ lighten_lch),
/* harmony export */   "pm": () => (/* binding */ lighten_hsl),
/* harmony export */   "eP": () => (/* binding */ lighten_hsv),
/* harmony export */   "Ir": () => (/* binding */ darken_lch),
/* harmony export */   "nZ": () => (/* binding */ darken_hsl),
/* harmony export */   "dN": () => (/* binding */ darken_hsv),
/* harmony export */   "VL": () => (/* binding */ desaturate_hsv),
/* harmony export */   "TV": () => (/* binding */ desaturate_hsl),
/* harmony export */   "Ei": () => (/* binding */ desaturate_lch),
/* harmony export */   "c": () => (/* binding */ mix_with_colour),
/* harmony export */   "cv": () => (/* binding */ offset),
/* harmony export */   "MV": () => (/* binding */ offset_red),
/* harmony export */   "Yc": () => (/* binding */ offset_green),
/* harmony export */   "FJ": () => (/* binding */ offset_blue),
/* harmony export */   "ou": () => (/* binding */ multiple_offsets),
/* harmony export */   "T$": () => (/* binding */ primary),
/* harmony export */   "SJ": () => (/* binding */ colorize),
/* harmony export */   "x": () => (/* binding */ solarize),
/* harmony export */   "Qf": () => (/* binding */ solarize_retimg),
/* harmony export */   "DT": () => (/* binding */ inc_brightness),
/* harmony export */   "NC": () => (/* binding */ adjust_contrast),
/* harmony export */   "nV": () => (/* binding */ tint),
/* harmony export */   "YX": () => (/* binding */ horizontal_strips),
/* harmony export */   "BG": () => (/* binding */ vertical_strips),
/* harmony export */   "vK": () => (/* binding */ oil),
/* harmony export */   "hh": () => (/* binding */ neue),
/* harmony export */   "xP": () => (/* binding */ lix),
/* harmony export */   "hg": () => (/* binding */ ryo),
/* harmony export */   "hX": () => (/* binding */ filter),
/* harmony export */   "aE": () => (/* binding */ lofi),
/* harmony export */   "jN": () => (/* binding */ pastel_pink),
/* harmony export */   "o3": () => (/* binding */ golden),
/* harmony export */   "fs": () => (/* binding */ cali),
/* harmony export */   "kw": () => (/* binding */ dramatic),
/* harmony export */   "og": () => (/* binding */ firenze),
/* harmony export */   "Mb": () => (/* binding */ obsidian),
/* harmony export */   "g$": () => (/* binding */ noise_reduction),
/* harmony export */   "dF": () => (/* binding */ sharpen),
/* harmony export */   "sW": () => (/* binding */ edge_detection),
/* harmony export */   "yR": () => (/* binding */ identity),
/* harmony export */   "vJ": () => (/* binding */ box_blur),
/* harmony export */   "zx": () => (/* binding */ gaussian_blur),
/* harmony export */   "eY": () => (/* binding */ detect_horizontal_lines),
/* harmony export */   "s6": () => (/* binding */ detect_vertical_lines),
/* harmony export */   "wO": () => (/* binding */ detect_45_deg_lines),
/* harmony export */   "kt": () => (/* binding */ detect_135_deg_lines),
/* harmony export */   "j9": () => (/* binding */ laplace),
/* harmony export */   "lf": () => (/* binding */ edge_one),
/* harmony export */   "D$": () => (/* binding */ emboss),
/* harmony export */   "WB": () => (/* binding */ sobel_horizontal),
/* harmony export */   "XJ": () => (/* binding */ prewitt_horizontal),
/* harmony export */   "c1": () => (/* binding */ sobel_vertical),
/* harmony export */   "VY": () => (/* binding */ SamplingFilter),
/* harmony export */   "nt": () => (/* binding */ PhotonImage),
/* harmony export */   "Ss": () => (/* binding */ Rgb),
/* harmony export */   "r1": () => (/* binding */ __wbindgen_json_serialize),
/* harmony export */   "ug": () => (/* binding */ __wbindgen_object_drop_ref),
/* harmony export */   "t$": () => (/* binding */ __wbindgen_json_parse),
/* harmony export */   "h9": () => (/* binding */ __wbg_new_59cb74e423758ede),
/* harmony export */   "Dz": () => (/* binding */ __wbg_stack_558ba5917b466edd),
/* harmony export */   "kF": () => (/* binding */ __wbg_error_4bb6c2a97407129a),
/* harmony export */   "S1": () => (/* binding */ __wbg_instanceof_Window_9c4fd26090e1d029),
/* harmony export */   "_4": () => (/* binding */ __wbg_document_249e9cf340780f93),
/* harmony export */   "$n": () => (/* binding */ __wbg_body_0d97f334de622953),
/* harmony export */   "Vi": () => (/* binding */ __wbg_createElement_ba61aad8af6be7f4),
/* harmony export */   "tQ": () => (/* binding */ __wbg_width_0c52428553322c27),
/* harmony export */   "ei": () => (/* binding */ __wbg_height_d9aa5f566b4ad3b1),
/* harmony export */   "jv": () => (/* binding */ __wbg_data_7db9e348ce1855fa),
/* harmony export */   "pj": () => (/* binding */ __wbg_newwithu8clampedarrayandsh_daf4b2743e8c858d),
/* harmony export */   "xO": () => (/* binding */ __wbg_instanceof_CanvasRenderingContext2d_eea9cd931eb496b7),
/* harmony export */   "HS": () => (/* binding */ __wbg_drawImage_8012170741749614),
/* harmony export */   "JF": () => (/* binding */ __wbg_getImageData_6e56dc172cd2ed36),
/* harmony export */   "OI": () => (/* binding */ __wbg_putImageData_a0ab6f94c11984ac),
/* harmony export */   "MP": () => (/* binding */ __wbg_settextContent_fa342bf9999ed3eb),
/* harmony export */   "DM": () => (/* binding */ __wbg_appendChild_6ae001e6d3556190),
/* harmony export */   "ke": () => (/* binding */ __wbg_instanceof_HtmlCanvasElement_e0e251da2aa0b541),
/* harmony export */   "li": () => (/* binding */ __wbg_width_5843e31ec081f978),
/* harmony export */   "Yw": () => (/* binding */ __wbg_setwidth_fd251e9da5abcced),
/* harmony export */   "cl": () => (/* binding */ __wbg_height_872c06b1bc666dd9),
/* harmony export */   "xo": () => (/* binding */ __wbg_setheight_5b882973e84fa13c),
/* harmony export */   "o1": () => (/* binding */ __wbg_getContext_d778ffc8203f64ae),
/* harmony export */   "YD": () => (/* binding */ __wbg_call_cb478d88f3068c91),
/* harmony export */   "m_": () => (/* binding */ __wbindgen_object_clone_ref),
/* harmony export */   "Yu": () => (/* binding */ __wbg_newnoargs_3efc7bfa69a681f9),
/* harmony export */   "M8": () => (/* binding */ __wbg_self_05c54dcacb623b9a),
/* harmony export */   "JC": () => (/* binding */ __wbg_window_9777ce446d12989f),
/* harmony export */   "IV": () => (/* binding */ __wbg_globalThis_f0ca0bbb0149cf3d),
/* harmony export */   "VB": () => (/* binding */ __wbg_global_c3c8325ae8c7f1a9),
/* harmony export */   "XP": () => (/* binding */ __wbindgen_is_undefined),
/* harmony export */   "fY": () => (/* binding */ __wbindgen_debug_string),
/* harmony export */   "Or": () => (/* binding */ __wbindgen_throw),
/* harmony export */   "nD": () => (/* binding */ __wbindgen_rethrow)
/* harmony export */ });
/* harmony import */ var _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(641);
/* module decorator */ module = __webpack_require__.hmd(module);


const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let WASM_VECTOR_LEN = 0;

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(_watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);
    }
    return cachegetUint8Memory0;
}

const lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;

let cachedTextEncoder = new lTextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(_watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);
    }
    return cachegetInt32Memory0;
}

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}
/**
* @returns {any}
*/
function defaultConfig() {
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.defaultConfig();
    return takeObject(ret);
}

/**
* @returns {string}
*/
function id() {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.id(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);
    }
}

/**
* @returns {string}
*/
function name() {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.name(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);
    }
}

/**
* @returns {string}
*/
function description() {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.description(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);
    }
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* @param {any} config
* @param {Uint8Array} data
* @returns {Uint8Array}
*/
function process(config, data) {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = passArray8ToWasm0(data, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.process(retptr, addHeapObject(config), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
    }
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
* Alter a select channel by incrementing or decrementing its value by a constant.
*
* # Arguments
* * `img` - A PhotonImage.
* * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,
* representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)
* * `amount` - The amount to increment/decrement the channel's value by for that pixel.
* A positive value will increment/decrement the channel's value, a negative value will decrement the channel's value.
*
* ## Example
*
* ```no_run
* // For example, to increase the Red channel for all pixels by 10:
* use photon_rs::channels::alter_channel;
* use photon_rs::native::{open_image};
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_channel(&mut img, 0_usize, 10_i16);
* ```
*
* Adds a constant to a select R, G, or B channel's value.
*
* ### Decrease a channel's value
* // For example, to decrease the Green channel for all pixels by 20:
* ```no_run
* use photon_rs::channels::alter_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_channel(&mut img, 1_usize, -20_i16);
* ```
* **Note**: Note the use of a minus symbol when decreasing the channel.
* @param {PhotonImage} img
* @param {number} channel
* @param {number} amt
*/
function alter_channel(img, channel, amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_channel(img.ptr, channel, amt);
}

/**
* Increment or decrement every pixel's Red channel by a constant.
*
* # Arguments
* * `img` - A PhotonImage. See the PhotonImage struct for details.
* * `amt` - The amount to increment or decrement the channel's value by for that pixel.
*
* # Example
*
* ```no_run
* // For example, to increase the Red channel for all pixels by 10:
* use photon_rs::channels::alter_red_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_red_channel(&mut img, 10_i16);
* ```
* @param {PhotonImage} photon_image
* @param {number} amt
*/
function alter_red_channel(photon_image, amt) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_red_channel(photon_image.ptr, amt);
}

/**
* Increment or decrement every pixel's Green channel by a constant.
*
* # Arguments
* * `img` - A PhotonImage.
* * `amt` - The amount to increment/decrement the channel's value by for that pixel.
*
* # Example
*
* ```no_run
* // For example, to increase the Green channel for all pixels by 20:
* use photon_rs::channels::alter_green_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_green_channel(&mut img, 20_i16);
* ```
* @param {PhotonImage} img
* @param {number} amt
*/
function alter_green_channel(img, amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_green_channel(img.ptr, amt);
}

/**
* Increment or decrement every pixel's Blue channel by a constant.
*
* # Arguments
* * `img` - A PhotonImage.
* * `amt` - The amount to increment or decrement the channel's value by for that pixel.
*
* # Example
*
* ```no_run
* // For example, to increase the Blue channel for all pixels by 10:
* use photon_rs::channels::alter_blue_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_blue_channel(&mut img, 10_i16);
* ```
* @param {PhotonImage} img
* @param {number} amt
*/
function alter_blue_channel(img, amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_blue_channel(img.ptr, amt);
}

/**
* Increment/decrement two channels' values simultaneously by adding an amt to each channel per pixel.
*
* # Arguments
* * `img` - A PhotonImage.
* * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.
* * `amt1` - The amount to increment/decrement the channel's value by for that pixel.
* * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.
* * `amt2` - The amount to increment/decrement the channel's value by for that pixel.
*
* # Example
*
* ```no_run
* // For example, to increase the values of the Red and Blue channels per pixel:
* use photon_rs::channels::alter_two_channels;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_two_channels(&mut img, 0_usize, 10_i16, 2_usize, 20_i16);
* ```
* @param {PhotonImage} img
* @param {number} channel1
* @param {number} amt1
* @param {number} channel2
* @param {number} amt2
*/
function alter_two_channels(img, channel1, amt1, channel2, amt2) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_two_channels(img.ptr, channel1, amt1, channel2, amt2);
}

/**
* Increment all 3 channels' values by adding an amt to each channel per pixel.
*
* # Arguments
* * `img` - A PhotonImage.
* * `r_amt` - The amount to increment/decrement the Red channel by.
* * `g_amt` - The amount to increment/decrement the Green channel by.
* * `b_amt` - The amount to increment/decrement the Blue channel by.
*
* # Example
*
* ```no_run
* // For example, to increase the values of the Red channel by 10, the Green channel by 20,
* // and the Blue channel by 50:
* use photon_rs::channels::alter_channels;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* alter_channels(&mut img, 10_i16, 20_i16, 50_i16);
* ```
* @param {PhotonImage} img
* @param {number} r_amt
* @param {number} g_amt
* @param {number} b_amt
*/
function alter_channels(img, r_amt, g_amt, b_amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.alter_channels(img.ptr, r_amt, g_amt, b_amt);
}

/**
* Set a certain channel to zero, thus removing the channel's influence in the pixels' final rendered colour.
*
* # Arguments
* * `img` - A PhotonImage.
* * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.
* * `min_filter` - Minimum filter. Value between 0 and 255. Only remove the channel if the current pixel's channel value is less than this minimum filter. To completely
* remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,
* then channel would be 0 and min_filter would be 50.
*
* # Example
*
* ```no_run
* // For example, to remove the Red channel with a min_filter of 100:
* use photon_rs::channels::remove_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* remove_channel(&mut img, 0_usize, 100_u8);
* ```
* @param {PhotonImage} img
* @param {number} channel
* @param {number} min_filter
*/
function remove_channel(img, channel, min_filter) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.remove_channel(img.ptr, channel, min_filter);
}

/**
* Remove the Red channel's influence in an image.
*
* # Arguments
* * `img` - A PhotonImage.
* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.
*
* # Example
*
* ```no_run
* // For example, to remove the red channel for red channel pixel values less than 50:
* use photon_rs::channels::remove_red_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* remove_red_channel(&mut img, 50_u8);
* ```
* @param {PhotonImage} img
* @param {number} min_filter
*/
function remove_red_channel(img, min_filter) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.remove_red_channel(img.ptr, min_filter);
}

/**
* Remove the Green channel's influence in an image.
*
* # Arguments
* * `img` - A PhotonImage.
* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.
*
* # Example
*
* ```no_run
* // For example, to remove the green channel for green channel pixel values less than 50:
* use photon_rs::channels::remove_green_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* remove_green_channel(&mut img, 50_u8);
* ```
* @param {PhotonImage} img
* @param {number} min_filter
*/
function remove_green_channel(img, min_filter) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.remove_green_channel(img.ptr, min_filter);
}

/**
* Remove the Blue channel's influence in an image.
*
* # Arguments
* * `img` - A PhotonImage.
* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.
*
* # Example
*
* ```no_run
* // For example, to remove the blue channel for blue channel pixel values less than 50:
* use photon_rs::channels::remove_blue_channel;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* remove_blue_channel(&mut img, 50_u8);
* ```
* @param {PhotonImage} img
* @param {number} min_filter
*/
function remove_blue_channel(img, min_filter) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.remove_blue_channel(img.ptr, min_filter);
}

/**
* Swap two channels.
*
* # Arguments
* * `img` - A PhotonImage.
* * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.
* * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.
*
* # Example
*
* ```no_run
* // For example, to swap the values of the Red channel with the values of the Blue channel:
* use photon_rs::channels::swap_channels;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* swap_channels(&mut img, 0_usize, 2_usize);
* ```
* @param {PhotonImage} img
* @param {number} channel1
* @param {number} channel2
*/
function swap_channels(img, channel1, channel2) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.swap_channels(img.ptr, channel1, channel2);
}

/**
* Invert RGB value of an image.
*
* # Arguments
* * `photon_image` - A DynamicImage that contains a view into the image.
* # Example
*
* ```no_run
* use photon_rs::channels::invert;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* invert(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function invert(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.invert(photon_image.ptr);
}

/**
* Selective hue rotation.
*
* Only rotate the hue of a pixel if its RGB values are within a specified range.
* This function only rotates a pixel's hue to another  if it is visually similar to the colour specified.
* For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.
* # Arguments
* * `img` - A PhotonImage.
* * `ref_color` - The `RGB` value of the reference color (to be compared to)
* * `degrees` - The amount of degrees to hue rotate by.
*
* # Example
*
* ```no_run
* // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:
* use photon_rs::Rgb;
* use photon_rs::channels::selective_hue_rotate;
* use photon_rs::native::open_image;
*
* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* selective_hue_rotate(&mut img, ref_color, 180_f32);
* ```
* @param {PhotonImage} photon_image
* @param {Rgb} ref_color
* @param {number} degrees
*/
function selective_hue_rotate(photon_image, ref_color, degrees) {
    _assertClass(photon_image, PhotonImage);
    _assertClass(ref_color, Rgb);
    var ptr0 = ref_color.ptr;
    ref_color.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.selective_hue_rotate(photon_image.ptr, ptr0, degrees);
}

/**
* Selectively lighten an image.
*
* Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.
* For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.
* # Arguments
* * `img` - A PhotonImage.
* * `ref_color` - The `RGB` value of the reference color (to be compared to)
* * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1
*
* # Example
*
* ```no_run
* // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:
* use photon_rs::Rgb;
* use photon_rs::channels::selective_lighten;
* use photon_rs::native::open_image;
*
* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* selective_lighten(&mut img, ref_color, 0.2_f32);
* ```
* @param {PhotonImage} img
* @param {Rgb} ref_color
* @param {number} amt
*/
function selective_lighten(img, ref_color, amt) {
    _assertClass(img, PhotonImage);
    _assertClass(ref_color, Rgb);
    var ptr0 = ref_color.ptr;
    ref_color.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.selective_lighten(img.ptr, ptr0, amt);
}

/**
* Selectively desaturate pixel colours which are similar to the reference colour provided.
*
* Similarity between two colours is calculated via the CIE76 formula.
* Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.
* For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.
* # Arguments
* * `img` - A PhotonImage.
* * `ref_color` - The `RGB` value of the reference color (to be compared to)
* * `amt` - The amount of desaturate the colour by.
*
* # Example
*
* ```no_run
* // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:
* use photon_rs::Rgb;
* use photon_rs::channels::selective_desaturate;
* use photon_rs::native::open_image;
*
* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* selective_desaturate(&mut img, ref_color, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {Rgb} ref_color
* @param {number} amt
*/
function selective_desaturate(img, ref_color, amt) {
    _assertClass(img, PhotonImage);
    _assertClass(ref_color, Rgb);
    var ptr0 = ref_color.ptr;
    ref_color.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.selective_desaturate(img.ptr, ptr0, amt);
}

/**
* Selectively saturate pixel colours which are similar to the reference colour provided.
*
* Similarity between two colours is calculated via the CIE76 formula.
* Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.
* For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.
* # Arguments
* * `img` - A PhotonImage.
* * `ref_color` - The `RGB` value of the reference color (to be compared to)
* * `amt` - The amount of saturate the colour by.
*
* # Example
*
* ```no_run
* // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:
* use photon_rs::Rgb;
* use photon_rs::channels::selective_saturate;
* use photon_rs::native::open_image;
*
* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* selective_saturate(&mut img, ref_color, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {Rgb} ref_color
* @param {number} amt
*/
function selective_saturate(img, ref_color, amt) {
    _assertClass(img, PhotonImage);
    _assertClass(ref_color, Rgb);
    var ptr0 = ref_color.ptr;
    ref_color.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.selective_saturate(img.ptr, ptr0, amt);
}

/**
* Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.
* Only changes the colour of a pixel if its RGB values are within a specified range.
*
* (Similarity between two colours is calculated via the CIE76 formula.)
* For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be
* kept in the photo.
* # Arguments
* * `img` - A PhotonImage.
* * `ref_color` - The `RGB` value of the reference color (to be compared to)
*
* # Example
*
* ```no_run
* // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:
* use photon_rs::Rgb;
* use photon_rs::channels::selective_greyscale;
* use photon_rs::native::open_image;
*
* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* selective_greyscale(img, ref_color);
* ```
* @param {PhotonImage} photon_image
* @param {Rgb} ref_color
*/
function selective_greyscale(photon_image, ref_color) {
    _assertClass(photon_image, PhotonImage);
    var ptr0 = photon_image.ptr;
    photon_image.ptr = 0;
    _assertClass(ref_color, Rgb);
    var ptr1 = ref_color.ptr;
    ref_color.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.selective_greyscale(ptr0, ptr1);
}

/**
* Crop an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to crop an image at (0, 0) to (500, 800)
* use photon_rs::native::{open_image};
* use photon_rs::transform::crop;
* use photon_rs::PhotonImage;
*
* let mut img = open_image("img.jpg").expect("File should open");
* let cropped_img: PhotonImage = crop(&mut img, 0_u32, 0_u32, 500_u32, 800_u32);
* // Write the contents of this image in JPG format.
* ```
* @param {PhotonImage} photon_image
* @param {number} x1
* @param {number} y1
* @param {number} x2
* @param {number} y2
* @returns {PhotonImage}
*/
function crop(photon_image, x1, y1, x2, y2) {
    _assertClass(photon_image, PhotonImage);
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.crop(photon_image.ptr, x1, y1, x2, y2);
    return PhotonImage.__wrap(ret);
}

/**
* @param {HTMLCanvasElement} source_canvas
* @param {number} width
* @param {number} height
* @param {number} left
* @param {number} top
* @returns {HTMLCanvasElement}
*/
function crop_img_browser(source_canvas, width, height, left, top) {
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.crop_img_browser(addHeapObject(source_canvas), width, height, left, top);
    return takeObject(ret);
}

/**
* Flip an image horizontally.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to flip an image horizontally:
* use photon_rs::native::open_image;
* use photon_rs::transform::fliph;
*
* let mut img = open_image("img.jpg").expect("File should open");
* fliph(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function fliph(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.fliph(photon_image.ptr);
}

/**
* Flip an image vertically.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to flip an image vertically:
* use photon_rs::native::open_image;
* use photon_rs::transform::flipv;
*
* let mut img = open_image("img.jpg").expect("File should open");
* flipv(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function flipv(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.flipv(photon_image.ptr);
}

/**
* Resize an image on the web.
*
* # Arguments
* * `img` - A PhotonImage.
* * `width` - New width.
* * `height` - New height.
* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5
* @param {PhotonImage} photon_img
* @param {number} width
* @param {number} height
* @param {number} sampling_filter
* @returns {HTMLCanvasElement}
*/
function resize_img_browser(photon_img, width, height, sampling_filter) {
    _assertClass(photon_img, PhotonImage);
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.resize_img_browser(photon_img.ptr, width, height, sampling_filter);
    return takeObject(ret);
}

/**
* Resize an image.
*
* # Arguments
* * `img` - A PhotonImage.
* * `width` - New width.
* * `height` - New height.
* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5
* @param {PhotonImage} photon_img
* @param {number} width
* @param {number} height
* @param {number} sampling_filter
* @returns {PhotonImage}
*/
function resize(photon_img, width, height, sampling_filter) {
    _assertClass(photon_img, PhotonImage);
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.resize(photon_img.ptr, width, height, sampling_filter);
    return PhotonImage.__wrap(ret);
}

/**
* Resize image using seam carver.
* Resize only if new dimensions are smaller, than original image.
* # NOTE: This is still experimental feature, and pretty slow.
*
* # Arguments
* * `img` - A PhotonImage.
* * `width` - New width.
* * `height` - New height.
*
* # Example
*
* ```no_run
* // For example, resize image using seam carver:
* use photon_rs::native::open_image;
* use photon_rs::transform::seam_carve;
* use photon_rs::PhotonImage;
*
* let img = open_image("img.jpg").expect("File should open");
* let result: PhotonImage = seam_carve(&img, 100_u32, 100_u32);
* ```
* @param {PhotonImage} img
* @param {number} width
* @param {number} height
* @returns {PhotonImage}
*/
function seam_carve(img, width, height) {
    _assertClass(img, PhotonImage);
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.seam_carve(img.ptr, width, height);
    return PhotonImage.__wrap(ret);
}

/**
* Apply a monochrome effect of a certain colour.
*
* It does so by averaging the R, G, and B values of a pixel, and then adding a
* separate value to that averaged value for each channel to produce a tint.
* # Arguments
* * `photon_image` - A PhotonImage.
* * `r_offset` - The value to add to the Red channel per pixel.
* * `g_offset` - The value to add to the Green channel per pixel.
* * `b_offset` - The value to add to the Blue channel per pixel.
*
* # Example
*
* ```no_run
* // For example, to apply a monochrome effect to an image:
* use photon_rs::monochrome::monochrome;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* monochrome(&mut img, 40_u32, 50_u32, 100_u32);
* ```
* @param {PhotonImage} img
* @param {number} r_offset
* @param {number} g_offset
* @param {number} b_offset
*/
function monochrome(img, r_offset, g_offset, b_offset) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.monochrome(img.ptr, r_offset, g_offset, b_offset);
}

/**
* Convert an image to sepia.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to sepia an image of type `PhotonImage`:
* use photon_rs::monochrome::sepia;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* sepia(&mut img);
* ```
* @param {PhotonImage} img
*/
function sepia(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.sepia(img.ptr);
}

/**
* Convert an image to grayscale using the conventional averaging algorithm.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to convert an image of type `PhotonImage` to grayscale:
* use photon_rs::monochrome::grayscale;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* grayscale(&mut img);
* ```
* @param {PhotonImage} img
*/
function grayscale(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.grayscale(img.ptr);
}

/**
* Convert an image to grayscale with a human corrected factor, to account for human vision.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to convert an image of type `PhotonImage` to grayscale with a human corrected factor:
* use photon_rs::monochrome::grayscale_human_corrected;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* grayscale_human_corrected(&mut img);
* ```
* @param {PhotonImage} img
*/
function grayscale_human_corrected(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.grayscale_human_corrected(img.ptr);
}

/**
* Desaturate an image by getting the min/max of each pixel's RGB values.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to desaturate an image:
* use photon_rs::monochrome::desaturate;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* desaturate(&mut img);
* ```
* @param {PhotonImage} img
*/
function desaturate(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.desaturate(img.ptr);
}

/**
* Uses a min. decomposition algorithm to convert an image to greyscale.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to decompose an image with min decomposition:
* use photon_rs::monochrome::decompose_min;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* decompose_min(&mut img);
* ```
* @param {PhotonImage} img
*/
function decompose_min(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.decompose_min(img.ptr);
}

/**
* Uses a max. decomposition algorithm to convert an image to greyscale.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* // For example, to decompose an image with max decomposition:
* use photon_rs::monochrome::decompose_max;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* decompose_max(&mut img);
* ```
* @param {PhotonImage} img
*/
function decompose_max(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.decompose_max(img.ptr);
}

/**
* Employ only a limited number of gray shades in an image.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `num_shades` - The number of grayscale shades to be displayed in the image.
* # Example
*
* ```no_run
* // For example, to limit an image to four shades of gray only:
* use photon_rs::monochrome::grayscale_shades;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* grayscale_shades(&mut img, 4_u8);
* ```
* @param {PhotonImage} photon_image
* @param {number} num_shades
*/
function grayscale_shades(photon_image, num_shades) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.grayscale_shades(photon_image.ptr, num_shades);
}

/**
* Convert an image to grayscale by setting a pixel's 3 RGB values to the Red channel's value.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::monochrome::r_grayscale;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* r_grayscale(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function r_grayscale(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.r_grayscale(photon_image.ptr);
}

/**
* Convert an image to grayscale by setting a pixel's 3 RGB values to the Green channel's value.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::monochrome::g_grayscale;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* g_grayscale(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function g_grayscale(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.g_grayscale(photon_image.ptr);
}

/**
* Convert an image to grayscale by setting a pixel's 3 RGB values to the Blue channel's value.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::monochrome::b_grayscale;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* b_grayscale(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function b_grayscale(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.b_grayscale(photon_image.ptr);
}

/**
* Convert an image to grayscale by setting a pixel's 3 RGB values to a chosen channel's value.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.
* # Example
* To grayscale using only values from the Red channel:
* ```no_run
* use photon_rs::monochrome::single_channel_grayscale;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* single_channel_grayscale(&mut img, 0_usize);
* ```
* @param {PhotonImage} photon_image
* @param {number} channel
*/
function single_channel_grayscale(photon_image, channel) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.single_channel_grayscale(photon_image.ptr, channel);
}

/**
* Threshold an image using a standard thresholding algorithm.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `threshold` - The amount the image should be thresholded by from 0 to 255.
* # Example
*
* ```no_run
* // For example, to threshold an image of type `PhotonImage`:
* use photon_rs::monochrome::threshold;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* threshold(&mut img, 30_u32);
* ```
* @param {PhotonImage} img
* @param {number} threshold
*/
function threshold(img, threshold) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.threshold(img.ptr, threshold);
}

/**
* Add a watermark to an image.
*
* # Arguments
* * `img` - A DynamicImage that contains a view into the image.
* * `watermark` - The watermark to be placed onto the `img` image.
* * `x` - The x coordinate where the watermark's top corner should be positioned.
* * `y` - The y coordinate where the watermark's top corner should be positioned.
* # Example
*
* ```no_run
* // For example, to add a watermark to an image at x: 30, y: 40:
* use photon_rs::multiple::watermark;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* let water_mark = open_image("watermark.jpg").expect("File should open");
* watermark(&mut img, &water_mark, 30_u32, 40_u32);
* ```
* @param {PhotonImage} img
* @param {PhotonImage} watermark
* @param {number} x
* @param {number} y
*/
function watermark(img, watermark, x, y) {
    _assertClass(img, PhotonImage);
    _assertClass(watermark, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.watermark(img.ptr, watermark.ptr, x, y);
}

/**
* Blend two images together.
*
* The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.
* The blend modes available include: `overlay`, `over`, `atop`, `xor`, `multiply`, `burn`, `soft_light`, `hard_light`,
* `difference`, `lighten`, `darken`, `dodge`, `plus`, `exclusion` (more to come)
* NOTE: The first image must be smaller than the second image passed as params.
* If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels
* in the second image.
* # Arguments
* * `img` - A DynamicImage that contains a view into the image.
* * `img2` - The 2nd DynamicImage to be blended with the first.
* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.
* # Example
*
* ```no_run
* // For example, to blend two images with the `multiply` blend mode:
* use photon_rs::multiple::blend;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* let img2 = open_image("img2.jpg").expect("File should open");
* blend(&mut img, &img2, "multiply");
* ```
* @param {PhotonImage} photon_image
* @param {PhotonImage} photon_image2
* @param {string} blend_mode
*/
function blend(photon_image, photon_image2, blend_mode) {
    _assertClass(photon_image, PhotonImage);
    _assertClass(photon_image2, PhotonImage);
    var ptr0 = passStringToWasm0(blend_mode, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.blend(photon_image.ptr, photon_image2.ptr, ptr0, len0);
}

/**
* @param {number} width
* @param {number} height
* @returns {PhotonImage}
*/
function create_gradient(width, height) {
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.create_gradient(width, height);
    return PhotonImage.__wrap(ret);
}

/**
* Apply a gradient to an image.
* @param {PhotonImage} image
*/
function apply_gradient(image) {
    _assertClass(image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.apply_gradient(image.ptr);
}

/**
*! [temp] Check if WASM is supported.
*/
function run() {
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.run();
}

let stack_pointer = 32;

function addBorrowedObject(obj) {
    if (stack_pointer == 1) throw new Error('out of js stack');
    heap[--stack_pointer] = obj;
    return stack_pointer;
}
/**
* Get the ImageData from a 2D canvas context
* @param {HTMLCanvasElement} canvas
* @param {CanvasRenderingContext2D} ctx
* @returns {ImageData}
*/
function get_image_data(canvas, ctx) {
    try {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.get_image_data(addBorrowedObject(canvas), addBorrowedObject(ctx));
        return takeObject(ret);
    } finally {
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
    }
}

/**
* Place a PhotonImage onto a 2D canvas.
* @param {HTMLCanvasElement} canvas
* @param {CanvasRenderingContext2D} ctx
* @param {PhotonImage} new_image
*/
function putImageData(canvas, ctx, new_image) {
    _assertClass(new_image, PhotonImage);
    var ptr0 = new_image.ptr;
    new_image.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.putImageData(addHeapObject(canvas), addHeapObject(ctx), ptr0);
}

/**
* Convert a HTML5 Canvas Element to a PhotonImage.
*
* This converts the ImageData found in the canvas context to a PhotonImage,
* which can then have effects or filters applied to it.
* @param {HTMLCanvasElement} canvas
* @param {CanvasRenderingContext2D} ctx
* @returns {PhotonImage}
*/
function open_image(canvas, ctx) {
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.open_image(addHeapObject(canvas), addHeapObject(ctx));
    return PhotonImage.__wrap(ret);
}

/**
* Convert ImageData to a raw pixel vec of u8s.
* @param {ImageData} imgdata
* @returns {Uint8Array}
*/
function to_raw_pixels(imgdata) {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.to_raw_pixels(retptr, addHeapObject(imgdata));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v0 = getArrayU8FromWasm0(r0, r1).slice();
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);
        return v0;
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Convert a base64 string to a PhotonImage.
* @param {string} base64
* @returns {PhotonImage}
*/
function base64_to_image(base64) {
    var ptr0 = passStringToWasm0(base64, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.base64_to_image(ptr0, len0);
    return PhotonImage.__wrap(ret);
}

/**
* Convert a base64 string to a Vec of u8s.
* @param {string} base64
* @returns {Uint8Array}
*/
function base64_to_vec(base64) {
    try {
        const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = passStringToWasm0(base64, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.base64_to_vec(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Convert a PhotonImage to JS-compatible ImageData.
* @param {PhotonImage} photon_image
* @returns {ImageData}
*/
function to_image_data(photon_image) {
    _assertClass(photon_image, PhotonImage);
    var ptr0 = photon_image.ptr;
    photon_image.ptr = 0;
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.to_image_data(ptr0);
    return takeObject(ret);
}

/**
* Apply gamma correction.
* Image manipulation effects in the LCh colour space
*
* Effects include:
* * **saturate** - Saturation increase.
* * **desaturate** - Desaturate the image.
* * **shift_hue** - Hue rotation by a specified number of degrees.
* * **darken** - Decrease the brightness.
* * **lighten** - Increase the brightness.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`
* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.
* # Example
* ```no_run
* // For example to increase the saturation by 10%:
* use photon_rs::colour_spaces::lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* lch(&mut img, "saturate", 0.1_f32);
* ```
* @param {PhotonImage} photon_image
* @param {string} mode
* @param {number} amt
*/
function lch(photon_image, mode, amt) {
    _assertClass(photon_image, PhotonImage);
    var ptr0 = passStringToWasm0(mode, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lch(photon_image.ptr, ptr0, len0, amt);
}

/**
* Image manipulation effects in the HSL colour space.
*
* Effects include:
* * **saturate** - Saturation increase.
* * **desaturate** - Desaturate the image.
* * **shift_hue** - Hue rotation by a specified number of degrees.
* * **darken** - Decrease the brightness.
* * **lighten** - Increase the brightness.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`
* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.
* # Example
* ```no_run
* // For example to increase the saturation by 10%:
* use photon_rs::colour_spaces::hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* hsl(&mut img, "saturate", 0.1_f32);
* ```
* @param {PhotonImage} photon_image
* @param {string} mode
* @param {number} amt
*/
function hsl(photon_image, mode, amt) {
    _assertClass(photon_image, PhotonImage);
    var ptr0 = passStringToWasm0(mode, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hsl(photon_image.ptr, ptr0, len0, amt);
}

/**
* Image manipulation in the HSV colour space.
*
* Effects include:
* * **saturate** - Saturation increase.
* * **desaturate** - Desaturate the image.
* * **shift_hue** - Hue rotation by a specified number of degrees.
* * **darken** - Decrease the brightness.
* * **lighten** - Increase the brightness.
*
* # Arguments
* * `photon_image` - A PhotonImage.
* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`
* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.
*
* # Example
* ```no_run
* // For example to increase the saturation by 10%:
* use photon_rs::colour_spaces::hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* hsv(&mut img, "saturate", 0.1_f32);
* ```
* @param {PhotonImage} photon_image
* @param {string} mode
* @param {number} amt
*/
function hsv(photon_image, mode, amt) {
    _assertClass(photon_image, PhotonImage);
    var ptr0 = passStringToWasm0(mode, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hsv(photon_image.ptr, ptr0, len0, amt);
}

/**
* Shift hue by a specified number of degrees in the HSL colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.
*
* # Example
* ```no_run
* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:
* use photon_rs::colour_spaces::hue_rotate_hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* hue_rotate_hsl(&mut img, 120_f32);
* ```
* @param {PhotonImage} img
* @param {number} degrees
*/
function hue_rotate_hsl(img, degrees) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_hsl(img.ptr, degrees);
}

/**
* Shift hue by a specified number of degrees in the HSV colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.
*
* # Example
* ```no_run
* // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:
* use photon_rs::colour_spaces::hue_rotate_hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* hue_rotate_hsv(&mut img, 120_f32);
* ```
* @param {PhotonImage} img
* @param {number} degrees
*/
function hue_rotate_hsv(img, degrees) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_hsv(img.ptr, degrees);
}

/**
* Shift hue by a specified number of degrees in the LCh colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.
*
* # Example
* ```no_run
* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:
* use photon_rs::colour_spaces::hue_rotate_lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* hue_rotate_lch(&mut img, 120_f32);
* ```
* @param {PhotonImage} img
* @param {number} degrees
*/
function hue_rotate_lch(img, degrees) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.hue_rotate_lch(img.ptr, degrees);
}

/**
* Increase the image's saturation by converting each pixel's colour to the HSL colour space
* and increasing the colour's saturation.
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Increasing saturation by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to increase saturation by 10% in the HSL colour space:
* use photon_rs::colour_spaces::saturate_hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* saturate_hsl(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function saturate_hsl(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.saturate_hsl(img.ptr, level);
}

/**
* Increase the image's saturation in the LCh colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Increasing saturation by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to increase saturation by 40% in the Lch colour space:
* use photon_rs::colour_spaces::saturate_lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* saturate_lch(&mut img, 0.4_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function saturate_lch(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.saturate_lch(img.ptr, level);
}

/**
* Increase the image's saturation in the HSV colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Increasing saturation by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to increase saturation by 30% in the HSV colour space:
* use photon_rs::colour_spaces::saturate_hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* saturate_hsv(&mut img, 0.3_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function saturate_hsv(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.saturate_hsv(img.ptr, level);
}

/**
* Lighten an image by a specified amount in the LCh colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Lightening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to lighten an image by 10% in the LCh colour space:
* use photon_rs::colour_spaces::lighten_lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* lighten_lch(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function lighten_lch(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lighten_lch(img.ptr, level);
}

/**
* Lighten an image by a specified amount in the HSL colour space.
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Lightening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to lighten an image by 10% in the HSL colour space:
* use photon_rs::colour_spaces::lighten_hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* lighten_hsl(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function lighten_hsl(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lighten_hsl(img.ptr, level);
}

/**
* Lighten an image by a specified amount in the HSV colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Lightening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to lighten an image by 10% in the HSV colour space:
* use photon_rs::colour_spaces::lighten_hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* lighten_hsv(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function lighten_hsv(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lighten_hsv(img.ptr, level);
}

/**
* Darken the image by a specified amount in the LCh colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Darkening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to darken an image by 10% in the LCh colour space:
* use photon_rs::colour_spaces::darken_lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* darken_lch(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function darken_lch(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.darken_lch(img.ptr, level);
}

/**
* Darken the image by a specified amount in the HSL colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Darkening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to darken an image by 10% in the HSL colour space:
* use photon_rs::colour_spaces::darken_hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* darken_hsl(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function darken_hsl(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.darken_hsl(img.ptr, level);
}

/**
* Darken the image's colours by a specified amount in the HSV colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Darkening by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to darken an image by 10% in the HSV colour space:
* use photon_rs::colour_spaces::darken_hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* darken_hsv(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function darken_hsv(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.darken_hsv(img.ptr, level);
}

/**
* Desaturate the image by a specified amount in the HSV colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Desaturating by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to desaturate an image by 10% in the HSV colour space:
* use photon_rs::colour_spaces::desaturate_hsv;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* desaturate_hsv(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function desaturate_hsv(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.desaturate_hsv(img.ptr, level);
}

/**
* Desaturate the image by a specified amount in the HSL colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Desaturating by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to desaturate an image by 10% in the LCh colour space:
* use photon_rs::colour_spaces::desaturate_hsl;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* desaturate_hsl(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function desaturate_hsl(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.desaturate_hsl(img.ptr, level);
}

/**
* Desaturate the image by a specified amount in the LCh colour space.
*
* # Arguments
* * `img` - A PhotonImage.
* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.
* The `level` must be from 0 to 1 in floating-point, `f32` format.
* Desaturating by 80% would be represented by a `level` of 0.8
*
* # Example
* ```no_run
* // For example to desaturate an image by 10% in the LCh colour space:
* use photon_rs::colour_spaces::desaturate_lch;
* use photon_rs::native::open_image;
*
* // Open the image. A PhotonImage is returned.
* let mut img = open_image("img.jpg").expect("File should open");
* desaturate_lch(&mut img, 0.1_f32);
* ```
* @param {PhotonImage} img
* @param {number} level
*/
function desaturate_lch(img, level) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.desaturate_lch(img.ptr, level);
}

/**
* Mix image with a single color, supporting passing `opacity`.
* The algorithm comes from Jimp. See `function mix` and `function colorFn` at following link:
* https://github.com/oliver-moran/jimp/blob/29679faa597228ff2f20d34c5758e4d2257065a3/packages/plugin-color/src/index.js
* Specifically, result_value = (mix_color_value - origin_value) * opacity + origin_value =
* mix_color_value * opacity + (1 - opacity) * origin_value for each
* of RGB channel.
*
* # Arguments
* * `photon_image` - A PhotonImage that contains a view into the image.
* * `mix_color` - the color to be mixed in, as an RGB value.
* * `opacity` - the opacity of color when mixed to image. Float value from 0 to 1.
* # Example
*
* ```no_run
* // For example, to mix an image with rgb (50, 255, 254) and opacity 0.4:
* use photon_rs::Rgb;
* use photon_rs::colour_spaces::mix_with_colour;
* use photon_rs::native::open_image;
*
* let mix_colour = Rgb::new(50_u8, 255_u8, 254_u8);
* let mut img = open_image("img.jpg").expect("File should open");
* mix_with_colour(&mut img, mix_colour, 0.4_f32);
* ```
* @param {PhotonImage} photon_image
* @param {Rgb} mix_colour
* @param {number} opacity
*/
function mix_with_colour(photon_image, mix_colour, opacity) {
    _assertClass(photon_image, PhotonImage);
    _assertClass(mix_colour, Rgb);
    var ptr0 = mix_colour.ptr;
    mix_colour.ptr = 0;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.mix_with_colour(photon_image.ptr, ptr0, opacity);
}

/**
* Adds an offset to the image by a certain number of pixels.
*
* This creates an RGB shift effect.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `offset` - The offset is added to the pixels in the image.
* # Example
*
* ```no_run
* // For example, to offset pixels by 30 pixels on the red channel:
* use photon_rs::effects::offset;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* offset(&mut img, 0_usize, 30_u32);
* ```
* @param {PhotonImage} photon_image
* @param {number} channel_index
* @param {number} offset
*/
function offset(photon_image, channel_index, offset) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.offset(photon_image.ptr, channel_index, offset);
}

/**
* Adds an offset to the red channel by a certain number of pixels.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `offset` - The offset you want to move the red channel by.
* # Example
*
* ```no_run
* // For example, to add an offset to the red channel by 30 pixels.
* use photon_rs::effects::offset_red;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* offset_red(&mut img, 30_u32);
* ```
* @param {PhotonImage} img
* @param {number} offset_amt
*/
function offset_red(img, offset_amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.offset_red(img.ptr, offset_amt);
}

/**
* Adds an offset to the green channel by a certain number of pixels.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `offset` - The offset you want to move the green channel by.
* # Example
*
* ```no_run
* // For example, to add an offset to the green channel by 30 pixels.
* use photon_rs::effects::offset_green;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* offset_green(&mut img, 30_u32);
* ```
* @param {PhotonImage} img
* @param {number} offset_amt
*/
function offset_green(img, offset_amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.offset_green(img.ptr, offset_amt);
}

/**
* Adds an offset to the blue channel by a certain number of pixels.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `offset_amt` - The offset you want to move the blue channel by.
* # Example
* // For example, to add an offset to the green channel by 40 pixels.
*
* ```no_run
* use photon_rs::effects::offset_blue;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* offset_blue(&mut img, 40_u32);
* ```
* @param {PhotonImage} img
* @param {number} offset_amt
*/
function offset_blue(img, offset_amt) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.offset_blue(img.ptr, offset_amt);
}

/**
* Adds multiple offsets to the image by a certain number of pixels (on two channels).
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `offset` - The offset is added to the pixels in the image.
* # Example
*
* ```no_run
* // For example, to add a 30-pixel offset to both the red and blue channels:
* use photon_rs::effects::multiple_offsets;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* multiple_offsets(&mut img, 30_u32, 0_usize, 2_usize);
* ```
* @param {PhotonImage} photon_image
* @param {number} offset
* @param {number} channel_index
* @param {number} channel_index2
*/
function multiple_offsets(photon_image, offset, channel_index, channel_index2) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.multiple_offsets(photon_image.ptr, offset, channel_index, channel_index2);
}

/**
* Reduces an image to the primary colours.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* # Example
*
* ```no_run
* // For example, to add a primary colour effect to an image of type `DynamicImage`:
* use photon_rs::effects::primary;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* primary(&mut img);
* ```
* @param {PhotonImage} img
*/
function primary(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.primary(img.ptr);
}

/**
* Colorizes the green channels of the image.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* # Example
*
* ```no_run
* // For example, to colorize an image of type `PhotonImage`:
* use photon_rs::effects::colorize;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* colorize(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function colorize(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.colorize(photon_image.ptr);
}

/**
* Applies a solarizing effect to an image.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* # Example
*
* ```no_run
* // For example, to colorize an image of type `PhotonImage`:
* use photon_rs::effects::solarize;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* solarize(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function solarize(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.solarize(photon_image.ptr);
}

/**
* Applies a solarizing effect to an image and returns the resulting PhotonImage.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* # Example
*
* ```no_run
* // For example, to solarize "retimg" an image of type `PhotonImage`:
* use photon_rs::effects::solarize_retimg;
* use photon_rs::native::open_image;
* use photon_rs::PhotonImage;
*
* let img = open_image("img.jpg").expect("File should open");
* let result: PhotonImage = solarize_retimg(&img);
* ```
* @param {PhotonImage} photon_image
* @returns {PhotonImage}
*/
function solarize_retimg(photon_image) {
    _assertClass(photon_image, PhotonImage);
    var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.solarize_retimg(photon_image.ptr);
    return PhotonImage.__wrap(ret);
}

/**
* Increase the brightness of an image by a factor.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `brightness` - A u8 to add to the brightness.
* # Example
*
* ```no_run
* use photon_rs::effects::inc_brightness;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* inc_brightness(&mut img, 10_u8);
* ```
* @param {PhotonImage} photon_image
* @param {number} brightness
*/
function inc_brightness(photon_image, brightness) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.inc_brightness(photon_image.ptr, brightness);
}

/**
* Adjust the contrast of an image by a factor.
*
* # Arguments
* * `photon_image` - A PhotonImage that contains a view into the image.
* * `contrast` - An f32 factor used to adjust contrast. Between [-255.0, 255.0]. The algorithm will
* clamp results if passed factor is out of range.
* # Example
*
* ```no_run
* use photon_rs::effects::adjust_contrast;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* adjust_contrast(&mut img, 30_f32);
* ```
* @param {PhotonImage} photon_image
* @param {number} contrast
*/
function adjust_contrast(photon_image, contrast) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.adjust_contrast(photon_image.ptr, contrast);
}

/**
* Tint an image by adding an offset to averaged RGB channel values.
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `r_offset` - The amount the R channel should be incremented by.
* * `g_offset` - The amount the G channel should be incremented by.
* * `b_offset` - The amount the B channel should be incremented by.
* # Example
*
* ```no_run
* // For example, to tint an image of type `PhotonImage`:
* use photon_rs::effects::tint;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* tint(&mut img, 10_u32, 20_u32, 15_u32);
* ```
* @param {PhotonImage} photon_image
* @param {number} r_offset
* @param {number} g_offset
* @param {number} b_offset
*/
function tint(photon_image, r_offset, g_offset, b_offset) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.tint(photon_image.ptr, r_offset, g_offset, b_offset);
}

/**
* Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.
* @param {PhotonImage} photon_image
* @param {number} num_strips
*/
function horizontal_strips(photon_image, num_strips) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.horizontal_strips(photon_image.ptr, num_strips);
}

/**
* Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.
* @param {PhotonImage} photon_image
* @param {number} num_strips
*/
function vertical_strips(photon_image, num_strips) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.vertical_strips(photon_image.ptr, num_strips);
}

/**
* Turn an image into an oil painting
*
* # Arguments
* * `img` - A PhotonImage that contains a view into the image.
* * `radius` - Radius of each paint particle
* * `intesnity` - How artsy an Image should be
* # Example
*
* ```no_run
* // For example, to oil an image of type `PhotonImage`:
* use photon_rs::effects::oil;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* oil(&mut img, 4i32, 55.0);
* ```
* @param {PhotonImage} photon_image
* @param {number} radius
* @param {number} intensity
*/
function oil(photon_image, radius, intensity) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.oil(photon_image.ptr, radius, intensity);
}

/**
* Solarization on the Blue channel.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::neue;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* neue(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function neue(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.neue(photon_image.ptr);
}

/**
* Solarization on the Red and Green channels.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::lix;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* lix(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function lix(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lix(photon_image.ptr);
}

/**
* Solarization on the Red and Blue channels.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::ryo;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* ryo(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function ryo(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.ryo(photon_image.ptr);
}

/**
* Apply a filter to an image. Over 20 filters are available.
* The filters are as follows:
* * **oceanic**: Add an aquamarine-tinted hue to an image.
* * **islands**: Aquamarine tint.
* * **marine**: Add a green/blue mixed hue to an image.
* * **seagreen**: Dark green hue, with tones of blue.
* * **flagblue**: Royal blue tint
* * **liquid**: Blue-inspired tint.
* * **diamante**: Custom filter with a blue/turquoise tint.
* * **radio**: Fallout-style radio effect.
* * **twenties**: Slight-blue tinted historical effect.
* * **rosetint**: Rose-tinted filter.
* * **mauve**: Purple-infused filter.
* * **bluechrome**: Blue monochrome effect.
* * **vintage**: Vintage filter with a red tint.
* * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.
* * **serenity**: Custom filter with an increase in the Blue channel's values.
* # Arguments
* * `img` - A PhotonImage.
* * `filter_name` - The filter's name. Choose from the selection above, eg: "oceanic"
* # Example
*
* ```no_run
* // For example, to add a filter called "vintage" to an image:
* use photon_rs::filters::filter;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* filter(&mut img, "vintage");
* ```
* @param {PhotonImage} img
* @param {string} filter_name
*/
function filter(img, filter_name) {
    _assertClass(img, PhotonImage);
    var ptr0 = passStringToWasm0(filter_name, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.filter(img.ptr, ptr0, len0);
}

/**
* Apply a lofi effect to an image.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::lofi;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* lofi(&mut img);
* ```
* @param {PhotonImage} img
*/
function lofi(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.lofi(img.ptr);
}

/**
* Apply a rose tint to an image.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::pastel_pink;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* pastel_pink(&mut img);
* ```
* @param {PhotonImage} img
*/
function pastel_pink(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.pastel_pink(img.ptr);
}

/**
* Apply a vintage, golden hue to an image.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::golden;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* golden(&mut img);
* ```
* @param {PhotonImage} img
*/
function golden(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.golden(img.ptr);
}

/**
* Increased contrast filter effect.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::cali;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* cali(&mut img);
* ```
* @param {PhotonImage} img
*/
function cali(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.cali(img.ptr);
}

/**
* Greyscale effect with increased contrast.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::dramatic;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* dramatic(&mut img);
* ```
* @param {PhotonImage} img
*/
function dramatic(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.dramatic(img.ptr);
}

/**
* Apply a red hue, with increased contrast and brightness.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::firenze;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* firenze(&mut img);
* ```
* @param {PhotonImage} img
*/
function firenze(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.firenze(img.ptr);
}

/**
* Apply a greyscale effect with increased contrast.
*
* # Arguments
* * `img` - A PhotonImage.
* # Example
*
* ```no_run
* use photon_rs::filters::obsidian;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* obsidian(&mut img);
* ```
* @param {PhotonImage} img
*/
function obsidian(img) {
    _assertClass(img, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.obsidian(img.ptr);
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function handleError(f) {
    return function () {
        try {
            return f.apply(this, arguments);

        } catch (e) {
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_exn_store(addHeapObject(e));
        }
    };
}

let cachegetUint8ClampedMemory0 = null;
function getUint8ClampedMemory0() {
    if (cachegetUint8ClampedMemory0 === null || cachegetUint8ClampedMemory0.buffer !== _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer) {
        cachegetUint8ClampedMemory0 = new Uint8ClampedArray(_watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.memory.buffer);
    }
    return cachegetUint8ClampedMemory0;
}

function getClampedArrayU8FromWasm0(ptr, len) {
    return getUint8ClampedMemory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* Noise reduction.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to noise reduct an image:
* use photon_rs::conv::noise_reduction;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* noise_reduction(&mut img);
* ```
* Adds a constant to a select R, G, or B channel's value.
* @param {PhotonImage} photon_image
*/
function noise_reduction(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.noise_reduction(photon_image.ptr);
}

/**
* Sharpen an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to sharpen an image:
* use photon_rs::conv::sharpen;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* sharpen(&mut img);
* ```
* Adds a constant to a select R, G, or B channel's value.
* @param {PhotonImage} photon_image
*/
function sharpen(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.sharpen(photon_image.ptr);
}

/**
* Apply edge detection to an image, to create a dark version with its edges highlighted.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to increase the Red channel for all pixels by 10:
* use photon_rs::conv::edge_detection;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* edge_detection(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function edge_detection(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.edge_detection(photon_image.ptr);
}

/**
* Apply an identity kernel convolution to an image.
*
* # Arguments
* * `img` -A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply an identity kernel convolution:
* use photon_rs::conv::identity;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* identity(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function identity(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.identity(photon_image.ptr);
}

/**
* Apply a box blur effect.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply a box blur effect:
* use photon_rs::conv::box_blur;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* box_blur(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function box_blur(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.box_blur(photon_image.ptr);
}

/**
* Gaussian blur in linear time.
*
* Reference: http://blog.ivank.net/fastest-gaussian-blur.html
*
* # Arguments
* * `photon_image` - A PhotonImage
* * `radius` - blur radius
* # Example
*
* ```no_run
* use photon_rs::conv::gaussian_blur;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* gaussian_blur(&mut img, 3_i32);
* ```
* @param {PhotonImage} photon_image
* @param {number} radius
*/
function gaussian_blur(photon_image, radius) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.gaussian_blur(photon_image.ptr, radius);
}

/**
* Detect horizontal lines in an image, and highlight these only.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to display the horizontal lines in an image:
* use photon_rs::conv::detect_horizontal_lines;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* detect_horizontal_lines(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function detect_horizontal_lines(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.detect_horizontal_lines(photon_image.ptr);
}

/**
* Detect vertical lines in an image, and highlight these only.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to display the vertical lines in an image:
* use photon_rs::conv::detect_vertical_lines;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* detect_vertical_lines(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function detect_vertical_lines(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.detect_vertical_lines(photon_image.ptr);
}

/**
* Detect lines at a forty five degree angle in an image, and highlight these only.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to display the lines at a forty five degree angle in an image:
* use photon_rs::conv::detect_45_deg_lines;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* detect_45_deg_lines(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function detect_45_deg_lines(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.detect_45_deg_lines(photon_image.ptr);
}

/**
* Detect lines at a 135 degree angle in an image, and highlight these only.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to display the lines at a 135 degree angle in an image:
* use photon_rs::conv::detect_135_deg_lines;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* detect_135_deg_lines(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function detect_135_deg_lines(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.detect_135_deg_lines(photon_image.ptr);
}

/**
* Apply a standard laplace convolution.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply a laplace effect:
* use photon_rs::conv::laplace;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* laplace(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function laplace(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.laplace(photon_image.ptr);
}

/**
* Preset edge effect.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply this effect:
* use photon_rs::conv::edge_one;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* edge_one(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function edge_one(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.edge_one(photon_image.ptr);
}

/**
* Apply an emboss effect to an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply an emboss effect:
* use photon_rs::conv::emboss;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* emboss(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function emboss(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.emboss(photon_image.ptr);
}

/**
* Apply a horizontal Sobel filter to an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply a horizontal Sobel filter:
* use photon_rs::conv::sobel_horizontal;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* sobel_horizontal(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function sobel_horizontal(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.sobel_horizontal(photon_image.ptr);
}

/**
* Apply a horizontal Prewitt convolution to an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply a horizontal Prewitt convolution effect:
* use photon_rs::conv::prewitt_horizontal;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* prewitt_horizontal(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function prewitt_horizontal(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.prewitt_horizontal(photon_image.ptr);
}

/**
* Apply a vertical Sobel filter to an image.
*
* # Arguments
* * `img` - A PhotonImage.
*
* # Example
*
* ```no_run
* // For example, to apply a vertical Sobel filter:
* use photon_rs::conv::sobel_vertical;
* use photon_rs::native::open_image;
*
* let mut img = open_image("img.jpg").expect("File should open");
* sobel_vertical(&mut img);
* ```
* @param {PhotonImage} photon_image
*/
function sobel_vertical(photon_image) {
    _assertClass(photon_image, PhotonImage);
    _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.sobel_vertical(photon_image.ptr);
}

/**
*/
const SamplingFilter = Object.freeze({ Nearest:1,"1":"Nearest",Triangle:2,"2":"Triangle",CatmullRom:3,"3":"CatmullRom",Gaussian:4,"4":"Gaussian",Lanczos3:5,"5":"Lanczos3", });
/**
* Provides the image's height, width, and contains the image's raw pixels.
* For use when communicating between JS and WASM, and also natively.
*/
class PhotonImage {

    static __wrap(ptr) {
        const obj = Object.create(PhotonImage.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_photonimage_free(ptr);
    }
    /**
    * Create a new PhotonImage from a Vec of u8s, which represent raw pixels.
    * @param {Uint8Array} raw_pixels
    * @param {number} width
    * @param {number} height
    */
    constructor(raw_pixels, width, height) {
        var ptr0 = passArray8ToWasm0(raw_pixels, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_new(ptr0, len0, width, height);
        return PhotonImage.__wrap(ret);
    }
    /**
    * Create a new PhotonImage from a base64 string.
    * @param {string} base64
    * @returns {PhotonImage}
    */
    static new_from_base64(base64) {
        var ptr0 = passStringToWasm0(base64, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_new_from_base64(ptr0, len0);
        return PhotonImage.__wrap(ret);
    }
    /**
    * Create a new PhotonImage from a byteslice.
    * @param {Uint8Array} vec
    * @returns {PhotonImage}
    */
    static new_from_byteslice(vec) {
        var ptr0 = passArray8ToWasm0(vec, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_new_from_byteslice(ptr0, len0);
        return PhotonImage.__wrap(ret);
    }
    /**
    * Get the width of the PhotonImage.
    * @returns {number}
    */
    get_width() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_get_width(this.ptr);
        return ret >>> 0;
    }
    /**
    * Get the PhotonImage's pixels as a Vec of u8s.
    * @returns {Uint8Array}
    */
    get_raw_pixels() {
        try {
            const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_get_raw_pixels(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get the height of the PhotonImage.
    * @returns {number}
    */
    get_height() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_get_height(this.ptr);
        return ret >>> 0;
    }
    /**
    * Convert the PhotonImage to base64.
    * @returns {string}
    */
    get_base64() {
        try {
            const retptr = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(-16);
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_get_base64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_add_to_stack_pointer(16);
            _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Convert the PhotonImage's raw pixels to JS-compatible ImageData.
    * @returns {ImageData}
    */
    get_image_data() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_get_image_data(this.ptr);
        return takeObject(ret);
    }
    /**
    * Convert ImageData to raw pixels, and update the PhotonImage's raw pixels to this.
    * @param {ImageData} img_data
    */
    set_imgdata(img_data) {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.photonimage_set_imgdata(this.ptr, addHeapObject(img_data));
    }
}
/**
* RGB color type.
*/
class Rgb {

    static __wrap(ptr) {
        const obj = Object.create(Rgb.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_rgb_free(ptr);
    }
    /**
    * Create a new RGB struct.
    * @param {number} r
    * @param {number} g
    * @param {number} b
    */
    constructor(r, g, b) {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_new(r, g, b);
        return Rgb.__wrap(ret);
    }
    /**
    * Set the Red value.
    * @param {number} r
    */
    set_red(r) {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_set_red(this.ptr, r);
    }
    /**
    * Get the Green value.
    * @param {number} g
    */
    set_green(g) {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_set_green(this.ptr, g);
    }
    /**
    * Set the Blue value.
    * @param {number} b
    */
    set_blue(b) {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_set_blue(this.ptr, b);
    }
    /**
    * Get the Red value.
    * @returns {number}
    */
    get_red() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_get_red(this.ptr);
        return ret;
    }
    /**
    * Get the Green value.
    * @returns {number}
    */
    get_green() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_get_green(this.ptr);
        return ret;
    }
    /**
    * Get the Blue value.
    * @returns {number}
    */
    get_blue() {
        var ret = _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.rgb_get_blue(this.ptr);
        return ret;
    }
}

const __wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = JSON.stringify(obj === undefined ? null : obj);
    var ptr0 = passStringToWasm0(ret, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

const __wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

const __wbindgen_json_parse = function(arg0, arg1) {
    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

const __wbg_new_59cb74e423758ede = function() {
    var ret = new Error();
    return addHeapObject(ret);
};

const __wbg_stack_558ba5917b466edd = function(arg0, arg1) {
    var ret = getObject(arg1).stack;
    var ptr0 = passStringToWasm0(ret, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

const __wbg_error_4bb6c2a97407129a = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_free(arg0, arg1);
    }
};

const __wbg_instanceof_Window_9c4fd26090e1d029 = function(arg0) {
    var ret = getObject(arg0) instanceof Window;
    return ret;
};

const __wbg_document_249e9cf340780f93 = function(arg0) {
    var ret = getObject(arg0).document;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

const __wbg_body_0d97f334de622953 = function(arg0) {
    var ret = getObject(arg0).body;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

const __wbg_createElement_ba61aad8af6be7f4 = handleError(function(arg0, arg1, arg2) {
    var ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
});

const __wbg_width_0c52428553322c27 = function(arg0) {
    var ret = getObject(arg0).width;
    return ret;
};

const __wbg_height_d9aa5f566b4ad3b1 = function(arg0) {
    var ret = getObject(arg0).height;
    return ret;
};

const __wbg_data_7db9e348ce1855fa = function(arg0, arg1) {
    var ret = getObject(arg1).data;
    var ptr0 = passArray8ToWasm0(ret, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

const __wbg_newwithu8clampedarrayandsh_daf4b2743e8c858d = handleError(function(arg0, arg1, arg2, arg3) {
    var ret = new ImageData(getClampedArrayU8FromWasm0(arg0, arg1), arg2 >>> 0, arg3 >>> 0);
    return addHeapObject(ret);
});

const __wbg_instanceof_CanvasRenderingContext2d_eea9cd931eb496b7 = function(arg0) {
    var ret = getObject(arg0) instanceof CanvasRenderingContext2D;
    return ret;
};

const __wbg_drawImage_8012170741749614 = handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    getObject(arg0).drawImage(getObject(arg1), arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
});

const __wbg_getImageData_6e56dc172cd2ed36 = handleError(function(arg0, arg1, arg2, arg3, arg4) {
    var ret = getObject(arg0).getImageData(arg1, arg2, arg3, arg4);
    return addHeapObject(ret);
});

const __wbg_putImageData_a0ab6f94c11984ac = handleError(function(arg0, arg1, arg2, arg3) {
    getObject(arg0).putImageData(getObject(arg1), arg2, arg3);
});

const __wbg_settextContent_fa342bf9999ed3eb = function(arg0, arg1, arg2) {
    getObject(arg0).textContent = arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2);
};

const __wbg_appendChild_6ae001e6d3556190 = handleError(function(arg0, arg1) {
    var ret = getObject(arg0).appendChild(getObject(arg1));
    return addHeapObject(ret);
});

const __wbg_instanceof_HtmlCanvasElement_e0e251da2aa0b541 = function(arg0) {
    var ret = getObject(arg0) instanceof HTMLCanvasElement;
    return ret;
};

const __wbg_width_5843e31ec081f978 = function(arg0) {
    var ret = getObject(arg0).width;
    return ret;
};

const __wbg_setwidth_fd251e9da5abcced = function(arg0, arg1) {
    getObject(arg0).width = arg1 >>> 0;
};

const __wbg_height_872c06b1bc666dd9 = function(arg0) {
    var ret = getObject(arg0).height;
    return ret;
};

const __wbg_setheight_5b882973e84fa13c = function(arg0, arg1) {
    getObject(arg0).height = arg1 >>> 0;
};

const __wbg_getContext_d778ffc8203f64ae = handleError(function(arg0, arg1, arg2) {
    var ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2));
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
});

const __wbg_call_cb478d88f3068c91 = handleError(function(arg0, arg1) {
    var ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
});

const __wbindgen_object_clone_ref = function(arg0) {
    var ret = getObject(arg0);
    return addHeapObject(ret);
};

const __wbg_newnoargs_3efc7bfa69a681f9 = function(arg0, arg1) {
    var ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

const __wbg_self_05c54dcacb623b9a = handleError(function() {
    var ret = self.self;
    return addHeapObject(ret);
});

const __wbg_window_9777ce446d12989f = handleError(function() {
    var ret = window.window;
    return addHeapObject(ret);
});

const __wbg_globalThis_f0ca0bbb0149cf3d = handleError(function() {
    var ret = globalThis.globalThis;
    return addHeapObject(ret);
});

const __wbg_global_c3c8325ae8c7f1a9 = handleError(function() {
    var ret = __webpack_require__.g.global;
    return addHeapObject(ret);
});

const __wbindgen_is_undefined = function(arg0) {
    var ret = getObject(arg0) === undefined;
    return ret;
};

const __wbindgen_debug_string = function(arg0, arg1) {
    var ret = debugString(getObject(arg1));
    var ptr0 = passStringToWasm0(ret, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_malloc, _watermark_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

const __wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

const __wbindgen_rethrow = function(arg0) {
    throw takeObject(arg0);
};



/***/ }),

/***/ 641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
"use strict";
// Instantiate WebAssembly module
var wasmExports = __webpack_require__.w[module.id];

// export exports from WebAssembly module
module.exports = wasmExports;
// exec imports from WebAssembly module (for esm order)
/* harmony import */ var m0 = __webpack_require__(718);


// exec wasm module
wasmExports[""]()

/***/ })

}]);
//# sourceMappingURL=333.js.map